#### 一、File类

##### 1、构造方法：

###### 1.1、根据path自动创建文件或目录对象

###### 1.2、根据目录path和文件名创建文件对象

###### 1.3、根据目录File和文件名创建文件对象

###### 1.4、根据uri创建文件对象

```java
// pathname是实际存在的路径，File对象表示的是目录;pathname是文件名,File对象表示的是文件
public File(String pathname) {
    if (pathname == null) {
        throw new NullPointerException();
    }
    this.path = fs.normalize(pathname);
    this.prefixLength = fs.prefixLength(this.path);
}
// parent表示路径名,child表示的是文件名
public File(String parent, String child) {
    if (child == null) {
        throw new NullPointerException();
    }
    if (parent != null) {
        if (parent.equals("")) {
            this.path = fs.resolve(fs.getDefaultParent(),
                                   fs.normalize(child));
        } else {
            this.path = fs.resolve(fs.normalize(parent),
                                   fs.normalize(child));
        }
    } else {
        this.path = fs.normalize(child);
    }
    this.prefixLength = fs.prefixLength(this.path);
}
// parent表示的是路径对象,child表示的是文件名
public File(File parent, String child) {
    if (child == null) {
        throw new NullPointerException();
    }
    if (parent != null) {
        if (parent.path.equals("")) {
            this.path = fs.resolve(fs.getDefaultParent(),
                                   fs.normalize(child));
        } else {
            this.path = fs.resolve(parent.path,
                                   fs.normalize(child));
        }
    } else {
        this.path = fs.normalize(child);
    }
    this.prefixLength = fs.prefixLength(this.path);
}
// uri
public File(URI uri) {
    // Check our many preconditions
    if (!uri.isAbsolute())
        throw new IllegalArgumentException("URI is not absolute");
    if (uri.isOpaque())
        throw new IllegalArgumentException("URI is not hierarchical");
    String scheme = uri.getScheme();
    if ((scheme == null) || !scheme.equalsIgnoreCase("file"))
        throw new IllegalArgumentException("URI scheme is not \"file\"");
    if (uri.getAuthority() != null)
        throw new IllegalArgumentException("URI has an authority component");
    if (uri.getFragment() != null)
        throw new IllegalArgumentException("URI has a fragment component");
    if (uri.getQuery() != null)
        throw new IllegalArgumentException("URI has a query component");
    String p = uri.getPath();
    if (p.equals(""))
        throw new IllegalArgumentException("URI path component is empty");

    // Okay, now initialize
    p = fs.fromURIPath(p);
    if (File.separatorChar != '/')
        p = p.replace('/', File.separatorChar);
    this.path = fs.normalize(p);
    this.prefixLength = fs.prefixLength(this.path);
}
// 私有
private File(String pathname, int prefixLength) {
    this.path = pathname;
    this.prefixLength = prefixLength;
}
private File(String child, File parent) {
    assert parent.path != null;
    assert (!parent.path.equals(""));
    this.path = fs.resolve(parent.path, child);
    this.prefixLength = parent.prefixLength;
}
```



##### 2、属性

##### 3、方法

###### 3.1、获取文件或目录名称`getName()`

```
public String getName() {
    int index = path.lastIndexOf(separatorChar);
    if (index < prefixLength) return path.substring(prefixLength);
    return path.substring(index + 1);
}
```

###### 3.2、 获取抽象路径的父路径名的路径名字符串`getParent()`

```
public String getParent() {
    int index = path.lastIndexOf(separatorChar);
    if (index < prefixLength) {
        if ((prefixLength > 0) && (path.length() > prefixLength))
        return path.substring(0, prefixLength);
        return null;
    }
    return path.substring(0, index);
}
```

###### 3.3、   获取抽象路径的父路径文件`getParentFile()`

```
public File getParentFile() {
    String p = this.getParent();
    if (p == null) return null;
    return new File(p, this.prefixLength);
}
```

###### 3.4、获取此文件的路径字符串 `String getPath()`



###### 3.5、判断此文件路径是否为绝对路径`boolean isAbsolute()`



###### 3.6、返回文件的绝对路径字符串`String getAbsolutePath()`



###### 3.7、判断程序是否可以读取此抽象路径名表示的文件 `boolean canRead()`



###### 3.8、判断程序是否可以修改此抽象路径表示的文件`boolean canWrite()`



###### 3.9、判断此抽象路径表示的文件或目录石佛存在`boolean exists()`



###### 3.10、测试此抽象路径名表示的文件是否是一个目录 `boolean isDirectory()`



###### 3.11、测试此抽象路径名表示的文件是否是一个标准文件 `boolean isFile()`



3.12、返回此抽象路径名表示的文件最后一次被修改的时间 long lastModified()



3.13、返回此抽象文件名表示的文件的长度 long length()



3.14、当且仅当文件不存时，创建文件 boolean createNewFile() throws IOException



3.15、删除此抽象路径表示的文件或目录 `boolean delete()`

3.16、在虚拟机终止时，请求删除此抽象路径名表示的文件或目录 `void deleteOnExit()`

3.17、返回此抽象路径名所表示的目录中的文件和目录的名称所组成的字符串数组 `String[] list()`

3.18、按执行形式返回此抽象路径名所表示的目录中的文件和目录的名称所组成的字符串数组String[] list(FilenameFilter filter)

3.19、返回目录中所有文件 File[] listFiles()

3.20、File[] listFiles(FileFilter filter)

3.21、boolean mkdir()

3.22、boolean mkdirs()

3.23、boolean rename To(File dest)

3.24、setLastModified(long time)

3.25、setReadOnley()

3.26、public static File createTempFile(String prefix, String suffix, File directory) throws IOException

3.27、public static File createTempFile(String prefix, String suffix) throws IOException

3.28、pulic int compareTo(File pathname)

3.29、public int compareTo(Object o)

3.30、public boolean equals(Object obj)

3.31、public String toString()



#### 二、文件输入输出流

##### 1、输入与输出的区别

输入流：写入内存

输出流：从内存输出到其它设备，显示器、硬盘等

##### 2、流类型

字节流：处理字节相关，如声音或者图片等二进制 InputStream/OutputStream

字符流：按字符处理文件,如中文按不同编码  Read/Write

##### 3、常见输入输出流关系

##### 4、字节输入流

######  4.1 输入流`InputStream`

```java
int read()
// 从输入流中读取一个字节，返回0-到255范围内的int字节值,子节数据可直接转化为int类型，如果已经到达流末尾而没有可用的字节，则返回-1

int read(byte[] buf)
// 从输入流中读取一定数流的字节，并将其存储在缓冲区数组buf中，返回实际读取的字节数

long skip(long n)
// 从输入流中跳过并丢弃n个字节的数据

int available()
// 返回这个流中有多少个字节数，可以把buf数组长度定义为这个

void close() throws IOException
// 关闭输入流并释放与该流关联的系统资源
```

###### 4.2 文件输入流`FileInputStream`

```java
// 构造方法
public FileInputStream(File file) throws FileNotFoundException
public FileInputStream(String filePath) throws FileNotFoundException
```

案例：

```java
	@Test
	public void test01() {
		
		File file = new File("G:\\workspce\\eclipse-workspace\\java-se\\src\\course11_file\\doc\\test1.txt");
		
		try {
			InputStream in = new FileInputStream(file);
			System.out.println("文件最大字节数: " + in.available());
			int c;
			while ( (c = in.read()) != -1) {
				System.out.println((char) c);
			}
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
	}
	
	@Test
	public void test02() {
		File file = new File("G:\\workspce\\eclipse-workspace\\java-se\\src\\course11_file\\doc\\test1.txt");
		try {
			InputStream in = new FileInputStream(file);
			System.out.println("文件最大字节数: " + in.available());
			byte[] b = new byte[in.available()];
			in.read(b);
			in.close();
			String s = new String(b, "utf-8");
			System.out.println(s);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
	}
```



###### 4.3 BufferInputStream

###### 4.4 ObjectInputStream



###### 4.5 ByteArrayInputStream



##### 5、字节输出流

5.1 输出流`OutputStream`

```
// 将指定字节写入输出流
void write(byte b)

// 将字节数组写入输出流
void write(byte[] b) throws IOException

// write是写到缓冲区，可以认为是内存中，当缓冲区满时，系统会自动将缓冲区的内容写入文件，但是一般还有一部分可能留在缓冲区中，所有调用flush清空缓冲区数据，写入硬盘
void flush() throws IOException

// 关闭输入流，释放资源
void close() throws IOException

```

5.2  `FileOutputStream`

```java
	// 写入一个字节,65 代表a
	@Test
	public void test01() {
		try {
			FileOutputStream out = new FileOutputStream("G:\\workspce\\eclipse-workspace\\java-se\\src\\course11_file\\doc\\test1.txt", true);
			out.write((byte) 65);
			out.flush();
			out.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	// 写入一段话
	@Test
	public void test02() {
		try {
			FileOutputStream out = new FileOutputStream("G:\\workspce\\eclipse-workspace\\java-se\\src\\course11_file\\doc\\test1.txt", true);
			String s = "dafda的热温热fgfsdfgr";
			out.write(s.getBytes());
			out.flush();
			out.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
```

5.3  



5.4 

5.5 